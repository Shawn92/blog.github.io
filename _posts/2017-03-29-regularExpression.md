---
layout: post
title:  "正则表达式匹配"
categories: 代码笔记
tags: 正则表达式 leetcode 
author: Shawn
---

* content
{:toc}
## 题目一：正则表达式简单匹配

**问题描述:** 定义正则表达式的语法如下：

```
'*': 代表0个或者多个字母
'.'：代表一个字母
```

编写一个函数接受一个字符串s以及一个正则式p，检查s是否能够被p接受（匹配）

----------------------------------------------------





**函数原型：** `bool isMatch(string s, string p)`

**测试用例：** abE和*E匹配，也和*.E匹配，但是不和b*E匹配

**问题分析：** 这种正则表达式的匹配方案是最为简单的一种，其不需要考虑闭包的情况。基本思想使用递归来解决这一类问题，按情况讨论：
> 第一种情况：如果正则式和匹配串同时到达字符串末尾，递归函数结束并且返回true

> 第二种情况：如果正则式中当前的匹配字符是‘.’或者字母，那么就从匹配串种匹配一个字符，如果匹配成功则调用递归函数匹配下一个字符

> 第三种情况：如果正则式中当前的匹配字符是‘*’或者字母，那么先调用递归匹配剩下的正则式与匹配串是否匹配，如果匹配直接返回true，否则‘*’从匹配串中接收一个字符，然后再次执行此过程

## 代码一

```cpp
public class solution {
	bool reMatch(const char * s, const char * p) {
		if (*p == '\0')
			return *s == '\0';  /*如果正则式p和匹配串s同时达到结尾，则返回true*/
		if (*p != '*')   /*如果正在匹配的字符不是‘*’，即可能是‘.’或普通字符*/
		{
			if (*p == *s || (*p == '.' && *s != '\0')) /*匹配当前字符*/
				return reMatch(s + 1, p + 1);  /*当前字符匹配成功，匹配下一字符*/
			else
				return false;
		}
		else  /*如果正在匹配字符的下一个字符是‘*’*/
		{
			while (*s != '\0') {
				if (reMatch(s, p + 1))  /*先跳过下个字符‘*’，尝试用剩下的正则式参与匹配，如果直接匹配成功，则返回true*/
					return true;
				s++;  /*否则匹配串后移一位，也就是忽略了当前匹配字符，相当于其被‘*’接收*/
			}
			return reMatch(p + 1, s);  /*匹配字符串s达到结尾，检查正则式串p是否到达结尾*/
		}
	}

	bool isMatch(string s, string p) {
		return reMatch2(s.c_str(), p.c_str());
	}
}
```

------------------------------------------------------------------------

## 题目二：带闭包的正则表达式匹配（leetcode 10）

**问题描述:** 定义正则表达式的语法如下：

```
'.' 代表一个字母
'*' 代表0个或者多个前面字母，如`a*`代表匹配0个或多个字母a
```

编写一个函数接受一个字符串s以及一个正则式p，检查s是否能够被p接受（匹配）

**函数原型：** `bool isMatch(string s, string p)`

**问题分析：** 这里引入了闭包的概念，即每个'*'之前都有一个字母，依然使用递归的方法来解决，只需在问题一的基础上稍加改造。下面的代码在leetcode上已经AC。

## 代码二

```cpp
class Solution {
public:
    /*该方法匹配的是‘a^*b’类型的正则式*/
    bool reMatch(const char * s, const char * p) {
        if (*p == '\0')
		    return *s == '\0'; /*如果正则式p和匹配串s同时达到结尾，则返回true*/

    	if (*(p + 1) != '*')   /*如果正在匹配的下一个字符不是‘*’，即可能是‘.’或普通字符*/
    	{
    		if (*p == *s || (*p == '.' && *s != '\0')) /*匹配当前字符*/
    			return reMatch(s + 1, p + 1); /*如果当前字符匹配成功，匹配下一字符*/
    		else  /*否则返回false*/
    			return false;                           
    	}
    	else  /*如果正在匹配字符的下一个字符是‘*’，则表示当前字符可能需要匹配多次（>=0）*/
    	{
    	    while (*p == *s || (*p == '.' && *s != '\0'))
    	    {
    	        if (reMatch(s, p + 2))   /*先跳过下个字符‘*’，尝试用剩下的正则式参与匹配，如果直接匹配成功，则返回true*/
    	            return true;
    	        s++;  /*否则匹配串后移一位，也就是忽略了当前匹配字符，相当于其被‘*’接收*/
    	    }
    		return reMatch(s, p + 2);   /*当前字符的闭包匹配完毕，匹配下一字符*/
    	}
    }
    
    bool isMatch(string s, string p) {
        return reMatch(s.c_str(), p.c_str());
    }
};
```

