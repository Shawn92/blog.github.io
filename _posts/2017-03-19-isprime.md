---
layout: post
title:  "求M到N间的素数问题"
categories: 代码笔记
tags:  C++ 素数
author: Dora
---

* content
{:toc}

#  使用素数筛法求解素数
**问题原型：**给出一个范围`0<=M<=N`，列举出`[M,N]`范围内的所有素数.

-----------------------------------------------------------------------------






## 方法一：`isprime()`函数

使用库函数`siprime()`可以直接对`[M,N]`区间的数进行判断：
```cpp
for (int i = M; i <= N; ++i) {
	if (isprime(i)) cout << i << endl;
}
```

## 方法二：改进的素数筛法

在所有的求素数的方法中，素数筛是理解起来较为方便的一种，最简单的素数筛就是每次读取一个素数`i`，然后在标记数组中将所有`i`的整数倍`(2i,3i,...,k*i)`标记为非素数，这里给出了一种改进的加速素数筛方法：
```cpp
#define SIZE 10000

int isNotPrime[SIZE] = { 0 };
void getPrime() {
	isNotPrime[0] = isNotPrime[1] = 1;
	for (int i = 4; i < SIZE; ++i) {
		if (i % 2 == 0) isNotPrime[i] = 1;//1.筛去所有偶数
	}
	int t = sqrt(SIZE);
	for (int i = 3; i <= t; ++i) {
		if (!isNotPrime[i]) {    //i是素数
			for (int j = i * i; j < SIZE; j += i * 2) //2.j从i*i开始每次增加2i，做筛去操作
				isNotPrime[j] = 1;
		}
	}
}
```
上述方法与传统的素数筛相比主要优化了两处：

1. 首先度标记数组中所有的偶数（2除外）进行了筛去操作；
2. 对与某一个素数`i`	筛除操作从`i*i`处开始，每次增加的步长为`2i`,理由如下：
>首先传统的素数筛中存在重复筛查同一个数的问题，以`3`为例，假设素数的范围为`20`，则传统方法中需要依次筛除的数是`2*3,3*3,4*3,5*3,...,6*3`,而当对下一个素数`5`进行筛除操作时，需要筛除的数是`2*5,3*5,...,4*5`注意到`15=（3*5）`在以上两组需要筛除的数中都出现了，这就是重复的筛除。所以，对于素数`5`来说，应跳过`3*5`而直接从`5*5`开始，即从`i*i`开始；
另一方面，每次筛除增加的步长取`2*i`，这样需要筛除的数的序列变为`i*i,(i+2)i,(i+4)i,...`，避免了对于偶数数的重复删除工作。
